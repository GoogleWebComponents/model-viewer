<!--
/*
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-->
<!DOCTYPE html>
<html lang="en">
<head>
<title>FlightHelmet</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1">
<link href="https://google.github.io/filament/favicon.png" rel="icon" type="image/x-icon" />
<style>
html, body { height: 100%; }
body       { margin: 0; overflow: hidden; }
#container { position: relative; height: 100%; }
canvas     { position: absolute; width: 100%; height: 100%; }
#messages  { position: absolute; width: 100%; height: 100%; padding-left: 10px; }
</style>
</head>
<body>
<div id="container">
    <canvas></canvas>
    <pre id="messages"></pre>
</div>
<script src="../../../node_modules/filament/filament.js"></script>
<script src="https://unpkg.com/gltumble"></script>
<script>
function getUrlParams() {
  let params = {};
  let parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m,key,value) {
      params[key] = value;
  });
  return params;
}
const params = getUrlParams();
const background = params['background'].replace(/\/$/, "");
const environment_url=`IBL/${background}`;
const ibl_url = `${environment_url}/${background}_ibl.ktx`;
const sky_url = `${environment_url}/${background}_skybox.ktx`;
const mesh_url = params['model'];
Filament.init([mesh_url, ibl_url, sky_url], () => {
    window.gltfio = Filament.gltfio;
    window.Fov = Filament.Camera$Fov;
    window.LightType = Filament.LightManager$Type;
    window.app = new App(document.getElementsByTagName('canvas')[0]);
});
class App {
    constructor(canvas) {
        this.canvas = canvas;
        const engine = this.engine = Filament.Engine.create(this.canvas);
        const scene = this.scene = engine.createScene();
        // this.trackball = new Trackball(canvas, {startSpin: 0.0});
        // const sunlight = Filament.EntityManager.get().create();
        // Filament.LightManager.Builder(LightType.SUN)
        //     .color([0.98, 0.92, 0.89])
        //     .intensity(100000.0)
        //     .direction([0.6, -1.0, -0.8])
        //     .castShadows(false) // TODO: re-enable shadows after Chrome 74
        //     .sunAngularRadius(1.9)
        //     .sunHaloSize(10.0)
        //     .sunHaloFalloff(80.0)
        //     .build(engine, sunlight);
        // this.scene.addEntity(sunlight);
        const indirectLight = this.ibl = engine.createIblFromKtx(ibl_url);
        this.scene.setIndirectLight(indirectLight);
        // Functions on the indirectLight affect both the IBL and the skybox
        indirectLight.setIntensity(40000);
        indirectLight.setRotation([0, 0, -1, 0, 1, 0, 1, 0, 0]);// 90 degrees
        const skybox = engine.createSkyFromKtx(sky_url);
        this.scene.setSkybox(skybox);
        const loader = engine.createAssetLoader();
        const asset = this.asset = loader.createAssetFromBinary(mesh_url);
        const messages = document.getElementById('messages');
        this.boundingBox = {};
        this.boundingBox.min=[-1, -1, -1];
        this.boundingBox.max=[1, 1, 1];
        // Crudely indicate progress by printing the URL of each resource as it is loaded.
        // Note that we wait 1 ms after the last asset has downloaded, but before finalization.
        // This gives the browser time to display the latest status.
        const onFetched = (uri) => messages.innerText += `Downloaded ${uri}\n`;
        const onDone = (finalize) => {
            messages.innerText += 'Finalizing...\n'
            setTimeout(() => {
                finalize();
                loader.delete();
                const entities = asset.getEntities();
                scene.addEntities(entities);
                const loaded = new Event('model-loaded');
                this.boundingBox = asset.getBoundingBox();
                this.resize();
                canvas.dispatchEvent(loaded);
                messages.remove();
            }, 1);
        };
        asset.loadResources(onDone, onFetched);
        this.swapChain = engine.createSwapChain();
        this.renderer = engine.createRenderer();
        this.camera = engine.createCamera();
        this.view = engine.createView();
        this.view.setCamera(this.camera);
        this.view.setScene(this.scene);
        // const aperture = this.camera.getAperture();
        // const shutterSpeed = this.camera.getShutterSpeed();
        // const sensitivity = this.camera.getSensitivity();
        // this.camera.setExposure(aperture, shutterSpeed, sensitivity);
        
        this.resize();
        this.render = this.render.bind(this);
        this.resize = this.resize.bind(this);
        window.addEventListener('resize', this.resize);
        window.requestAnimationFrame(this.render);
    }
    render() {
        // const tcm = this.engine.getTransformManager();
        // const inst = tcm.getInstance(this.asset.getRoot());
        // tcm.setTransform(inst, this.trackball.getMatrix());
        // inst.delete();
        
        this.renderer.render(this.swapChain, this.view);
        window.requestAnimationFrame(this.render);
    }
    resize() {
        const dpr = window.devicePixelRatio;
        const width = this.canvas.width = window.innerWidth * dpr;
        const height = this.canvas.height = window.innerHeight * dpr;
        this.view.setViewport([0, 0, width, height]);
        const aspect = width / height;
        // const fov = aspect < 1 ? Fov.HORIZONTAL : Fov.VERTICAL;

        let target = [0, 0, 0];
        let eye = [0, 0, 0];
        for(let i = 0; i < 3; i++){
            target[i] = (this.boundingBox.min[i] + this.boundingBox.max[i]) / 2.0;
            eye[i] = target[i];
        }

        const boxHalfX = Math.max(
            Math.abs(this.boundingBox.min[0] - target[0]),
            Math.abs(this.boundingBox.max[0] - target[0]));
        const boxHalfZ = Math.max(
            Math.abs(this.boundingBox.min[2] - target[2]),
            Math.abs(this.boundingBox.max[2] - target[2]));
        const boxHalfY = Math.max(
            Math.abs(this.boundingBox.min[1] - target[1]),
            Math.abs(this.boundingBox.max[1] - target[1]));

        const modelDepth = 2 * Math.max(boxHalfX, boxHalfZ);
        const framedHeight = Math.max(2 * boxHalfY, modelDepth / aspect);

        const fov = 45;

        const framedDistance = (framedHeight / 2) /
              Math.tan((fov / 2) * Math.PI / 180);
        const near = framedHeight / 10.0;
        const far = framedHeight * 10.0;
        const cameraDistance = framedDistance + modelDepth / 2;

        this.camera.setProjectionFov(fov, aspect, near, far, Fov.VERTICAL);
        eye[2] += cameraDistance;
        const up = [0, 1, 0];
        this.camera.lookAt(eye, target, up);
    }
}
</script>
</body>
</html>